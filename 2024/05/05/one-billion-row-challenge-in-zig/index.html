<!DOCTYPE html>
<html>
  <head>
        <meta charset="utf-8">
    <title>
      
        One Billion Row Challenge in Zig &mdash;
      
      Jakob Külzer
    </title>

    <meta name="author" value="Jakob Külzer">
    <meta property="og:title" content="One Billion Row Challenge in Zig">
    <meta property="og:description" content="I finally got around to looking into The One Billion Row Challenge. If you&rsquo;re unfamiliar, it&rsquo;s a challenge to how fast a program can read and process one billion rows. It&rsquo;s fascinating because it&rsquo;s all about raw performance including algorithms, CPU instructions, and profiling and benchmarking. All things I enjoy dabbling with.
So one Saturday evening I started reading up on the challenge. The first thing that struck me was the top entries&rsquo; time: 1.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://ilikeorangutans.github.io/2024/05/05/one-billion-row-challenge-in-zig/">

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="alternate" href="https://ilikeorangutans.github.io/index.xml" type="application/rss+xml" title="Jakob Külzer">

    <link rel="stylesheet" href="/css/spectre.min.css">
    <link rel="stylesheet" href="/css/style.css">

    <link rel="canonical" href="https://ilikeorangutans.github.io/">

  </head>
  <body>
    
    <div class="container grid-lg">
  <header class="navbar hide-sm">
    <section class="navbar-section">
      <a href="/" class="navbar-brand">
        Jakob Külzer
      </a>
    </section>
    <section class="navbar-section">
      
        <a href="/" class="mr-2 ml-2">
          Home
        </a>
      
        <a href="/posts/" class="mr-2 ml-2">
          Blog
        </a>
      
        <a href="/projects/" class="mr-2 ml-2">
          Projects
        </a>
      
        <a href="/about/" class="mr-2 ml-2">
          About
        </a>
      
    </section>
  </header>

  <header class="show-sm columns">
    <div class="column col-12">
      <a href="/" class="navbar-brand">
        Jakob Külzer
      </a>
    </div>
    <div class="column col-12">
      
        <a href="/" class="mr-2 ml-1">
          Home
        </a>
      
        <a href="/posts/" class="mr-2 ml-1">
          Blog
        </a>
      
        <a href="/projects/" class="mr-2 ml-1">
          Projects
        </a>
      
        <a href="/about/" class="mr-2 ml-1">
          About
        </a>
      
    </div>
  </header>
</div>
<div class="divider"></div>
    
    <main class="container grid-lg content">
      
    <div class="columns mb-2">
        <div class="column">
            <p class="text-gray">
                05 May 2024


, tagged:


    <a href="/tags/one-billion-row-challenge" class="">
        one billion row challenge, 
    </a>

    <a href="/tags/zig" class="">
        zig, 
    </a>

    <a href="/tags/simd" class="">
        SIMD, 
    </a>

    <a href="/tags/performance" class="">
        performance
    </a>



            </p>
            <div class="divider"></div>
            
            <h1>One Billion Row Challenge in Zig</h1>
            <p>I finally got around to looking into <a href="https://github.com/gunnarmorling/1brc?tab=readme-ov-file">The One Billion Row Challenge</a>. If you&rsquo;re unfamiliar, it&rsquo;s a challenge to how fast a program can read and process one billion rows. It&rsquo;s fascinating because it&rsquo;s all about raw performance including algorithms, CPU instructions, and profiling and benchmarking. All things I enjoy dabbling with.</p>
<p>So one Saturday evening I started reading up on the challenge. The first thing that struck me was the <a href="https://www.morling.dev/blog/1brc-results-are-in/">top entries&rsquo;</a> time: 1.535 seconds! For reference, the input is 13 GB. I can&rsquo;t even dump the whole file to <code>/dev/null</code> in that short of a time. So clearly, lots to learn.</p>
<p>My first thought was to implement it in Go, but this kind of algorithmic challenge is perfect to learn new languages, and I haven&rsquo;t done enough in <a href="https://ziglang.org/">Zig</a> recently. The initial, naive implementation didn&rsquo;t go so well. With a reduced subset of 100,000,000 rows without any processing I was already at 4.8 seconds. This led to the next rabbit hole, how does one profile where your program spends your time. I have a lot of experience profiling Go programs with <a href="https://github.com/google/pprof">pprof</a> but not much with Linux&rsquo; <code>perf</code>. So here I go spelunking in another cavernous rabbit hole.</p>
<p>Initial readings tell me that I&rsquo;m not sure what to make of this at all. Conceptually I understand ~all~ most of these, but in practice I have no intuition for these numbers.
<img src="./perf-01.png" alt=""></p>
<p>After some poking around and cursory reading I found the right incantation to get perf to record and unwind the callstacks such that I can make sense of the output:</p>
<pre tabindex="0"><code>$ perf record -F99 --call-graph dwarf -- ./zig-out/bin/1brc measurements_100000.txt
</code></pre><p>Still not too clear on all the details here, but at least I recognize the symbols:</p>
<p><img src="./perf-callstacks.png" alt=""></p>
<p>What&rsquo;s surprising is the amount of time spent parsing floats for example is much lower than I would have expected. What&rsquo;s even more surprising is the amount of time spent in the reader, maybe I&rsquo;m using it wrong. I double checked the buffer sizes, but they were ok and doubling or tripling them made no difference. And then I spotted the problem: I was using <code>instream.readUntilDelimiterOrEof</code> which will read only a single line at best:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-zig" data-lang="zig"><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#069;font-weight:bold">var</span><span style="color:#bbb"> </span>instream<span style="color:#bbb"> </span><span style="color:#555">=</span><span style="color:#bbb"> </span>buffered_reader.reader();<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#069;font-weight:bold">var</span><span style="color:#bbb"> </span>buffer<span style="color:#555">:</span><span style="color:#bbb"> </span>[<span style="color:#f60">8192</span>]<span style="color:#078;font-weight:bold">u8</span><span style="color:#bbb"> </span><span style="color:#555">=</span><span style="color:#bbb"> </span><span style="color:#069;font-weight:bold">undefined</span>;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#069;font-weight:bold">while</span><span style="color:#bbb"> </span>(<span style="color:#069;font-weight:bold">try</span><span style="color:#bbb"> </span>instream.readUntilDelimiterOrEof(buf<span style="color:#555">:</span><span style="color:#bbb"> </span><span style="color:#555">&amp;</span>buffer,<span style="color:#bbb"> </span>delimiter<span style="color:#555">:</span><span style="color:#bbb"> </span><span style="color:#c30;font-weight:bold">&#39;\n&#39;</span>))<span style="color:#bbb"> </span><span style="color:#555">|</span>line<span style="color:#555">|</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">      </span><span style="color:#09f;font-style:italic">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#09f;font-style:italic"></span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span></span></span></code></pre></div><p>I rewrote the function to always read a full buffer of 8KB, and, without any processing, I got reading the entire file down to 2.5 seconds:</p>
<pre tabindex="0"><code>$ hyperfine &#39;./zig-out/bin/1brc measurements.txt&#39;
Benchmark 1: ./zig-out/bin/1brc measurements.txt
  Time (mean ± σ):      2.658 s ±  0.021 s    [User: 0.167 s, System: 2.483 s]
  Range (min … max):    2.640 s …  2.701 s    10 runs
</code></pre><p>My initial reaction was that the slow program is likely executing a lot more reads than it should and not knowing how to better measure reads I figured I&rsquo;d check the number of syscalls emitted by the program. The slow program raked up 3.5 million syscalls.</p>
<pre tabindex="0"><code> Performance counter stats for &#39;system wide&#39;:

         5,596,331      raw_syscalls:sys_enter
    47,825,420,000 ns   user_time
     2,827,345,000 ns   system_time

      50.702825947 seconds time elapsed
</code></pre><p>The fast one did only 5.6 million:</p>
<pre tabindex="0"><code>$ perf stat -e raw_syscalls:sys_enter,user_time,system_time -a ./zig-out/bin/1brc measurements.txt
loading measurements.txt
Read 13795239670 bytes

 Performance counter stats for &#39;system wide&#39;:

         3,497,434      raw_syscalls:sys_enter
       213,073,000 ns   user_time
     2,713,290,000 ns   system_time

       2.930230893 seconds time elapsed
</code></pre><p>Unfortunately the increase in syscalls (5.6 vs 3.5 million) does not quite scale with the program runtime (50 vs 2.5 seconds). My next observation was that the number of executed branches was significantly higher for my first implementation:</p>
<pre tabindex="0"><code>   188,650,271,726      branches:u                       #    3.640 G/sec
     1,510,203,162      branch-misses:u                  #    0.80% of all branches

      51.841402841 seconds time elapsed
</code></pre><p>That&rsquo;s 189 billion branches executed. Whereas the fast version only executed&hellip; 37 million.</p>
<pre tabindex="0"><code>        37,048,268      branches:u                       #   14.025 M/sec
         3,370,939      branch-misses:u                  #    9.10% of all branches

       2.755307734 seconds time elapsed
</code></pre><p>That&rsquo;ll do it. I don&rsquo;t know yet why <code>readUntilDelimiterOrEof</code> is so much slower, but having replaced it my program was already much faster. Took me some time to get it all tied together because Zig is different in several ways. But I got an initial working version and processing the full one billion rows and writing the output clocks in at 1:21. Not too shabby:</p>
<pre tabindex="0"><code>./zig-out/bin/1brc measurements.txt  56.07s user 25.11s system 99% cpu 1:21.86 total
</code></pre><p>Still a far cry from the winner of the challenge, but already way better than the baseline implementation of 5 minutes. These numbers are not directly comparable because they were produced on different hardware, but at least I&rsquo;m in the right wheelhouse.</p>
<p>Now the next challenge is to actually profile, analyze, and optimize my implementation. Which leads me to the next challenge: while I conceptually understand SIMD and cache locality, I have not a lot of mechanical intuition in this area. I don&rsquo;t even have much experience in the tools measuring these parameters. For now there&rsquo;s lots to read and learn. It&rsquo;s humbling to see how little I still understand, even after years and years of building software.</p>

            <div class="divider"></div>
        </div>
    </div>
    <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "ilikeorangutans" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    </main>
    
    <div class="divider"></div>
<div class="container grid-lg mb-2">
    <footer class="navbar text-gray">
        <section class="navbar-section">
            &copy; 2018 Jakob Külzer
        </section>
        <section class="navbar-center">
            <a href="mailto:jakob.kuelzer@gmail.com" class="btn btn-link">Email</a> |
            <a href="https://github.com/ilikeorangutans" target="_blank" class="btn btn-link">Github</a> |
            <a href="https://www.linkedin.com/in/jakobkuelzer/" target="_blank" class="btn btn-link">LinkedIn</a> |
            <a href="/index.xml" class="btn btn-link">RSS</a>
        </section>
        <section class="navbar-section"></section>
    </footer>
</div>

    
  </body>
</html>