<!doctype html><html><head><meta charset=utf-8><title>Using Golang and Graphviz to Visualize Complex Grails Applications &mdash;
Jakob Külzer</title><meta name=author value="Jakob Külzer"><meta property="og:title" content="Using Golang and Graphviz to Visualize Complex Grails Applications"><meta property="og:description" content="At work we are maintaining several large and complex grails applications. In order to improve stability and reliability, we&rsquo;re trying to increase test coverage. But as with all projects, time and resources are limited. In order to get a better understanding of what parts of the application are more important than others, I decided to use Graphviz to help me get a better overview of our applications.
Meet Graphviz
I discovered my love for the dot language when I used it years ago to analyze template hierarchies in a proprietary CMS system I worked on. In a nutshell, it lets you specify a graph with nodes and edges plus some extra attributes for labels, shapes etc. It&rsquo;s really a concise little language:"><meta property="og:type" content="article"><meta property="og:url" content="https://ilikeorangutans.github.io/2014/05/03/using-golang-and-graphviz-to-visualize-complex-grails-applications/"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/output.css><link rel=canonical href=https://ilikeorangutans.github.io/></head><body class="bg-gray-50 text-gray-900"><header class="bg-white shadow-sm border-b"><div class="max-w-4xl mx-auto px-4 py-6"><nav class="flex justify-between items-center"><a href=/ class=navbar-brand><h1 class="text-2xl font-bold text-teal-900 hover:text-orange-400 transition-colors">Jakob Külzer</h1></a><div class=space-x-6><a href=/ class="text-gray-600 hover:text-orange-400 transition-colors">Home</a>
<a href=/posts/ class="text-gray-600 hover:text-orange-400 transition-colors">Blog</a>
<a href=/projects/ class="text-gray-600 hover:text-orange-400 transition-colors">Projects</a>
<a href=/about/ class="text-gray-600 hover:text-orange-400 transition-colors">About</a></div></nav></div></header><main class="max-w-4xl mx-auto px-4 py-8"><article class="bg-white rounded-lg shadow-sm overflow-hidden"><div class=p-6><div class="text-sm text-gray-500"><time datetime=2014-05-03>3 May 2014
</time><time datetime=2018-03-28>• updated 28 Mar 2018</time></div><h1 class="text-3xl md:text-4xl font-bold text-gray-900 mb-4 leading-tight">Using Golang and Graphviz to Visualize Complex Grails Applications</h1><div class="flex items-center justify-between mb-8 pb-6 border-b border-gray-200"><div class="flex flex-wrap gap-2 mb-4"><a href=/tags/golang class="bg-gray-100 hover:bg-teal-100 text-gray-700 hover:text-teal-800 px-3 py-1 rounded-full text-sm font-medium transition-colors duration-200 cursor-pointer">Golang
</a><a href=/tags/go class="bg-gray-100 hover:bg-teal-100 text-gray-700 hover:text-teal-800 px-3 py-1 rounded-full text-sm font-medium transition-colors duration-200 cursor-pointer">Go
</a><a href=/tags/grails class="bg-gray-100 hover:bg-teal-100 text-gray-700 hover:text-teal-800 px-3 py-1 rounded-full text-sm font-medium transition-colors duration-200 cursor-pointer">Grails
</a><a href=/tags/graphviz class="bg-gray-100 hover:bg-teal-100 text-gray-700 hover:text-teal-800 px-3 py-1 rounded-full text-sm font-medium transition-colors duration-200 cursor-pointer">Graphviz
</a><a href=/tags/visualization class="bg-gray-100 hover:bg-teal-100 text-gray-700 hover:text-teal-800 px-3 py-1 rounded-full text-sm font-medium transition-colors duration-200 cursor-pointer">Visualization
</a><a href=/tags/software-development class="bg-gray-100 hover:bg-teal-100 text-gray-700 hover:text-teal-800 px-3 py-1 rounded-full text-sm font-medium transition-colors duration-200 cursor-pointer">Software Development</a></div></div><div class="prose prose-lg max-w-none"><p>At work we are maintaining several large and complex grails applications. In order to improve stability and reliability, we&rsquo;re trying to increase test coverage. But as with all projects, time and resources are limited. In order to get a better understanding of what parts of the application are more important than others, I decided to use <a href=http://www.graphviz.org/>Graphviz</a> to help me get a better overview of our applications.</p><h3 id=meet-graphviz>Meet Graphviz</h3><p>I discovered my love for the <a href=http://www.graphviz.org/content/dot-language>dot language</a> when I used it years ago to analyze template hierarchies in a proprietary CMS system I worked on. In a nutshell, it lets you specify a graph with nodes and edges plus some extra attributes for labels, shapes etc. It&rsquo;s really a concise little language:</p><pre><code>digraph MyGraph {
	A -&gt; B -&gt; D
	A -&gt; C
}
</code></pre><p>Graphviz comes with a handful of tools that allow you to render these graph definitions into different output formats, including PDF, PNG, or SVG. The short sample graph from above would look like this:</p><p><img src=/assets/images/graphviz-sample.png alt="Sample Graph"></p><p>It&rsquo;s a fantastic tool to document flows and all kind of graph like structures.</p><h3 id=using-golang-to-generate-graphviz-files>Using Golang to Generate Graphviz Files</h3><p>When I was working on the grails applications in question, I always had trouble understanding the complex service structure. There&rsquo;s a lot of them, and they all depend on other services. And that complicates making changes and is a potential source of mistakes.</p><p>Looking at the services and their dependencies I realized it was a graph and that with a little bit of work I could get a Graph definition in the dot language. I decided to go with Go, just to have some fun and get my mind off Groovy and Java and luckily there is already a full fledged <a href=https://code.google.com/p/gographviz/>graphviz Go implementation</a> which made things easy.</p><p>The actual Go app is quite straightforward and very hackish. Given a start directory, it traverses all subdirectories and finds all <code>.groovy</code> files that are either controllers or services which are added as Nodes in the graph. Then it scans each line for service definitions which are luckily name based. This involves a fair bit of string processing and has lots of flaws. Once a service definition is found, it is added as an edge to the graph. Repeat until everything has been processed and write out the <code>.dot</code> file, run it through <code>dot</code>, and enjoy the visualization.</p><h3 id=examples>Examples</h3><p>Here are the scrubbed graphs from two of the apps I&rsquo;m working on. They are huge, so click the link to get the full resolution version. Don&rsquo;t mind the silly names, I had to scrub a lot of the original names.</p><p><img src=/assets/images/sample-app-01.png alt="Sample Graph">
<a href=/assets/images/sample-app-01.png>App A Full Resolution[PNG 558K]</a></p><p><img src=/assets/images/sample-app-02.png alt="Sample Graph">
<a href=/assets/images/sample-app-02.png>App B Full Resolution[PNG 393K]</a></p><h3 id=analysis>Analysis</h3><p>Looking at the generated Graphs, several things quickly became apparent. First of all, it&rsquo;s very easy to see what services have the most afferent dependencies. This by itself makes it easy to spot crucial pieces of code that provide shared functionality to many other components.</p><p>But even more so, the layering of the services becomes apparent. Graphviz orders the nodes vertically based on the number of afferent and efferent dependencies. And at the bottom of the graph, you have all the services with only afferent dependencies which form the foundational layer of your application. This is the code that everything in your app relies on, either directly or transitively.</p><h3 id=further-ideas>Further Ideas</h3><p>Visualizing application structures is an incredibly useful, especially when working on complex and complicated systems. The above script took me less than an hour to write and the return is tremendous. I can now easily determine what to work on, what change could potentially affect other parts of the systems, and I can finally see the architecture of the application.</p><p>So far the visualization is rather simple. Bubbles for controllers and octagons for services. But there&rsquo;s so much more that could be done:</p><ul><li>Calculate the transitive number of dependencies a component has and adjust the size of the visual representation based on that. For example, a service used only by a single controller would be fairly small. Another service, used by twenty other services would be much bigger and more prominent. Fairly easy to implement.</li><li>Use afferent and <a href=http://en.wikipedia.org/wiki/Efferent_coupling>efferent</a> coupling to calculate the <a href=http://en.wikipedia.org/wiki/Software_package_metrics>instability</a> of services. Originally a metric for packages, this could probably applied to services as well. Could be visualized with border thickness of shapes.</li><li>Support different types of artifacts and give them different shapes. Right now I&rsquo;m thinking quartz jobs which play a fairly important role in our application.</li><li>Parse code instead of string searching. Right now I&rsquo;m simply scanning each source file line by line and search for certain patterns. This works reasonably well, but with some apps I get unwanted values. Sometimes from comments, sometimes other values. If I were to actually parse the source into an AST, all these issues would disappear. It would also allow a host of other interesting things, like:</li><li>Calculate the <a href=http://en.wikipedia.org/wiki/Cyclomatic_complexity>Cyclomatic Complexity</a> for each component and use that to colour code the visual representation. Low complexity could be a green tint, high values would be red.</li><li>Support different languages and frameworks. I was able to implement this tool very easily because Grails&rsquo; service and controller naming follows an entirely name based convention. That makes finding service definitions trivial. I would love to extend this tool to support different languages and frameworks.</li><li>Have more ideas? Drop me an email or a comment! :)</li></ul><p>The source code for the app is rather messy, but you can find it on <a href=https://github.com/ilikeorangutans/grails-service-visualizer>github.com/ilikeorangutans/grails-service-visualizer</a>.</p></div></div></article><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//ilikeorangutans.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></main><footer class="bg-white border-t mt-12"><div class="max-w-4xl mx-auto px-4 py-8"><div class="text-center text-gray-600"><p>&copy; 2025 Jakob Külzer. All rights reserved.</p><div class="mt-4 space-x-6"><a href=mailto:jakob.kuelzer@gmail.com class="hover:text-teal-600 transition-colors">Email</a>
<a href=https://github.com/ilikeorangutans target=_blank class="hover:text-teal-600 transition-colors">Github</a>
<a href=https://sr.ht/~ilikeorangutans/ target=_blank class="hover:text-teal-600 transition-colors">Sourcehut</a>
<a href=https://www.linkedin.com/in/jakobkuelzer/ target=_blank class="hover:text-teal-600 transition-colors">LinkedIn</a></div></div></div></footer></body></html>