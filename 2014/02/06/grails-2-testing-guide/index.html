<!DOCTYPE html>
<html>
  <head>
        <meta charset="utf-8">
    <title>
      Jakob Külzer
    </title>

    <meta name="author" value="Jakob Külzer">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="alternate" href="https://ilikeorangutans.github.io/index.xml" type="application/rss+xml" title="Jakob Külzer">

    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-exp.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-icons.min.css">
    <link rel="stylesheet" href="/css/style.css">

    <link rel="canonical" href="https://ilikeorangutans.github.io/">
  </head>
  <body>
    
    <div class="container grid-lg">
  <header class="navbar hide-sm">
    <section class="navbar-section">
      <a href="/" class="navbar-brand">
        Jakob Külzer
      </a>
    </section>
    <section class="navbar-section">
      
        <a href="/" class="btn btn-link">
          Home
        </a>
      
        <a href="/posts/" class="btn btn-link">
          Blog
        </a>
      
        <a href="/about/" class="btn btn-link">
          About
        </a>
      
    </section>
  </header>

  <header class="show-sm columns">
    <div class="column col-12">
      <a href="/" class="navbar-brand">
        Jakob Külzer
      </a>
    </div>
    <div class="column col-12">
      
        <a href="/" class="btn btn-link">
          Home
        </a>
      
        <a href="/posts/" class="btn btn-link">
          Blog
        </a>
      
        <a href="/about/" class="btn btn-link">
          About
        </a>
      
    </div>
  </header>
</div>
<div class="divider"></div>

    
    <main class="container grid-lg content">
      
    <div class="columns">
        <div class="column">
            <h1>Grails 2 Testing Guide</h1>
            

<p><strong>Note: I&rsquo;m still working on this post, but I already use it as a reference so there&rsquo;ll be more content over time.</strong></p>

<p>I&rsquo;ve been quite busy at work with updating a Grails 1.3 application to 2.3.4. While writing a test harness it became apparent that lots of things have changed since I&rsquo;ve last worked with Grails. Many changes are for the better, especially the integration of Spock framework. However, there were some issues that took me a while to figure out. The Grails docs on <a href="http://grails.org/doc/latest/guide/testing.html">testing</a> are comprehensive, but long. Here&rsquo;s my cheat sheet.</p>

<h2 id="general">General</h2>

<h3 id="tests-assertions">Tests &amp; Assertions</h3>

<p>Tests without assertions are mostly pointless. Learn to write effective assertions. <a href="https://code.google.com/p/hamcrest/wiki/Tutorial">Hamcrest matchers</a> are there to help you. If you&rsquo;re writing <a href="http://spockframework.org">Spock</a> tests, you don&rsquo;t even need to write any explicit asserts.</p>

<h3 id="use-appropriate-test-type">Use Appropriate Test Type</h3>

<p><em>Unit tests</em> are small, self contained, and quick. Whenever you want to test a single method or class, a unit test is usually the way to go. If you find yourself writing a unit test that relies on something else, you&rsquo;ll either want to make it an integration test or mock the collaborators. Using mocks you can precisely control what conditions your code runs under. You can control return values, exceptions, number of interactions, etc.
In Grails, unit tests go under <code>test/unit</code>.</p>

<p><em>Integration tests</em> are more sophisticated. They actually spin up the runtime environment with all its services, dependency injection, etc to provide a full system. Therefore they are slower than unit tests, but give you a better understanding how your components interact. I like to think of integration tests as tests that take an entire slice of the system and test the interactions between the involved classes. Integration tests go under <code>test/integration</code>.</p>

<h3 id="disabling-tests">Disabling Tests</h3>

<p>Whenever you need to disable a test, use the approriate annotation. Commenting out a test is not an acceptable solution. In GroovyUnit or regular JUnit tests, use <code>@org.junit.Ignore</code> and in Spock tests <code>@spock.lang.Ignore</code>. Notice that both annotations take a String parameter that communicates why this test was disabled. Use it to make it clear why a given test was disabled.</p>

<pre><code class="language-groovy">	@Ignore(&quot;do not need to test this right now&quot;)
	void &quot;test for a method&quot;() {
		// ...
	}
</code></pre>

<h3 id="never-mix-test-constructs">Never Mix Test Constructs</h3>

<p>Between unit and integration tests there are huge differences. <strong>Never mix constructs meant for unit tests with integration tests</strong>.</p>

<h3 id="groovyunit-or-spock">GroovyUnit or Spock</h3>

<p>Personally I find Spock tests much more expressive than GroovyUnit tests. Quick sample:</p>

<pre><code class="language-groovy">class FooSpecification extends Specification {
	void &quot;test for a method&quot;() {
		setup: // implicit, no need to declare this:

		// Everything after this statement will be treated as an assertion
		expect:

		add(2 + 2) == 4
	}
}
</code></pre>

<p>Check out the <a href="http://docs.spockframework.org/en/latest/">Spock docs</a>, <a href="https://code.google.com/p/spock/wiki/Examples">samples</a></p>

<h2 id="unit-tests">Unit Tests</h2>

<p>Unit tests are tests where you want to test only a very specific piece of code, a single unit. That means that all dependencies of that code will have to be mocked or stubbed. The test setup is the same for all unit tests and starts by annotating your unit test with the <code>@TestFor</code> annotation. This tells Grails what class you want to test and what variables to create.</p>

<pre><code class="language-groovy">@TestFor(MyController)
class MyControllerSpec extends Specification {

	void &quot;test something&quot;() {
		// Grails automatically created a controller field for us:
		controller.doSomething()
	}

}
</code></pre>

<h3 id="configuration">Configuration</h3>

<p>Grails&rsquo; config is usually accessed via an injected instance of <code>GrailsApplication</code> using the <code>config</code> property. Grails injects <code>GrailsApplication</code> into unit tests, so you can access it directly:</p>

<pre><code class="language-groovy">@TestMixin(GrailsUnitTestMixin)
class MySpec extends Specification {

	void &quot;test something with config&quot;() {
		// grailsApplication gets automatically injected
		grailsApplication.config.myConfigValue
	}

}
</code></pre>

<h3 id="mocks">Mocks</h3>

<p>During a unit test Grails will not create and inject any dependencies for you so it&rsquo;s up to you to do so. There&rsquo;s plenty of things your code interacts with and this section breaks down how to mock these things.</p>

<h4 id="mocking-logging">Mocking Logging</h4>

<p>Almost all loggers in Grails artifacts are injected automatically at runtime. However In unit tests you&rsquo;ll have to tell the framework explicitly what you want logging for.</p>

<p>TODO: Mock() - what does it do?</p>

<h4 id="mocking-domain-classes">Mocking Domain Classes</h4>

<p>Mocking domain classes is a quick and easy way to provide your test code with input. Mocking domain classes is easy, either you provide a <code>@grails.test.mixin.Mock</code> annotation with the domain classes you need, or you use the
<code>mockDomain()</code> method which is added to your test by the <code>GrailsUnitTestMixin</code>. One nice thing about the mocked domain objects is that they support most Gorm operations, including criteria and dynamic finders.</p>

<p>If you need to provide your test with data through mocks you can either just create the objects and save them or you can pass i</p>

<p>Example:</p>

<pre><code class="language-groovy">@TestFor(MyController)
@Mock([ AddressBook ])
class MyControllerSpec extends Specification {

	void setup() {
		// Explicitly create a new mocked domain object:
		AddressBook addressbook = new AddressBook(name: 'Personal Addressbook')
		addressBook.save()

		// Or provide an entry as a list.
		mockDomain(Entry, [
			[ firstName: 'Hans', lastName: 'Dampf', addressBook: addressBook ],
			[ firstName: 'Dr', lastName: 'Evil', addressBook: addressBook ]
		)
	}

	void &quot;test something&quot;() {
		// You can now use most Gorm related features, like get:
		AddressBook.get(1)

		// Dynamic finders:
		Entry.findByFirstName('Hans')

		// or Criteria:
		Entry.withCriteria {
			eq('lastName', 'Evil')
		}
	}
}
</code></pre>

<p><strong>Note</strong>: if you create test data with mocked domain objects, the constraints on the domain class <em>do</em> apply, even when using <code>mockDomain()</code>! I&rsquo;ve tripped over this a few times. If your mocked domain objects don&rsquo;t show up, make sure
you provide all the necessary fields.</p>

<h3 id="testing-controllers">Testing Controllers</h3>

<p>Testing controllers is straightforward, but requires lots of mocking as they rely on many different things: services, command objects, domain objects, etc.</p>

<h3 id="testing-closures">Testing Closures</h3>

<p>Methods that accept closures as parameters are a staple in Grails development. For example, the mail plugin uses the following syntax:</p>

<pre><code class="language-groovy">mailService.sendMail {
	from 'bazinga@test.com'
	to 'bingo@test.com'
	subject 'Amazing Stuff'
	text &quot;Send me your bank data and we'll make millions!&quot;
}
</code></pre>

<p>If you&rsquo;re mocking mailService the question is how to validate the values passed into the closure are correct. The solution is to create a <a href="http://stackoverflow.com/questions/10715919/how-to-mock-domain-specific-closures-in-spock">delegate for the closure</a> that captures the values which then can be verified:</p>

<pre><code class="language-groovy">class MailVerifier {
	String to, from, subject, text

	void to(String to) { this.to = to }
	void from(String from) { this.from = from }
	void subject(String subject) { this.subject = subject }
	void text(String text) { this.text = text }
}
</code></pre>

<p>In your test, you have to set the <code>MailVerifier</code> as the Closure&rsquo;s delegate (example uses Spock):</p>

<pre><code class="language-groovy">MailVerifier mv = new MailVerifier()
MailService mailService = Mock(MailService)
1 * mailService.sendMail(!null) &gt;&gt; { Closure c -&gt;
	c.delegate = mv // Set delegate
	c() // Execute closure
}

when:

doSomethingThatSendsMail('foo@bar.com', '...', )

then:

mv.to == 'foo@bar.com'
</code></pre>

<h3 id="unit-test-gotchas">Unit Test Gotchas</h3>

<p>This is a growing list of pain points and their solutions</p>

<h4 id="converterexception-unconvertable-object-of-class-xxx">ConverterException: Unconvertable Object of class XXX</h4>

<p>So you&rsquo;re writing a unit test for some service or other class, and after mocking everything out and putting the <code>@TestMixin(GrailsUnitTestMixin)</code> on your test, it blows up with an exception like this:</p>

<pre><code>Caused by: org.codehaus.groovy.grails.web.converters.exceptions.ConverterException: Unconvertable   Object of class: com.foobar.domain.MyDomainClass
    at grails.converters.JSON.value(JSON.java:199)
    at grails.converters.JSON.render(JSON.java:133)
    ... 41 more
</code></pre>

<p>The reason for this is that the <code>GrailsUnitTestMixin</code> does not initialize the converter subsystem. To get them working, add the <code>ControllerUnitTestMixin</code> mixin which will set up all the regular converters. See <a href="http://grails.1312388.n4.nabble.com/Error-using-as-JSON-converter-in-a-service-in-a-unit-test-tp4637433p4637457.html">this thread</a>. Example:</p>

<pre><code class="language-groovy">@TestMixin([GrailsUnitTestMixin, ControllerUnitTestMixin])
class ContactUsFormJobSpec extends Specification {
</code></pre>

<h4 id="groovy-lang-missingmethodexception-no-signature-of-method-com-foo-rainbow-addtocolors">groovy.lang.MissingMethodException: No signature of method: com.foo.Rainbow.addToColors()&hellip;</h4>

<p>This error happened a few times to me:</p>

<pre><code>|  groovy.lang.MissingMethodException: No signature of method: com.foo.Rainbow.addToColors() is applicable for argument types: (com.foo.RainbowColor) values: [RainbowColor{id=null, name=Orange}]
Possible solutions: getColors()
    at com.foo.RainbowServiceSpec.test
error(RainbowServiceSpec.groovy:179)
</code></pre>

<p>This happens when you write a unit test and mock only one of the domain classes, but not the other one. In the above example only <code>Rainbow</code> was mocked. Fix this by mocking all classes:</p>

<pre><code class="language-groovy">@TestFor(RainbowService)
@Mock([Rainbow, RainbowColor])
public class RainbowSpec extends Specification {}
</code></pre>

<h4 id="groovycastexception-cannot-cast-object-com-foo-rainbow-2f7af3-with-class-com-foo-rainbow-to-class-grails-converters-json">GroovyCastException: Cannot cast object &lsquo;com.foo.Rainbow@2f7af3&rsquo; with class &lsquo;com.foo.Rainbow&rsquo; to class &lsquo;grails.converters.JSON&rsquo;</h4>

<p>This seems to happen because the converters are not properly set up in certain unit tests. So lines like this will fail with the above exception:</p>

<pre><code>render rainbow as JSON
</code></pre>

<p>Best fix I&rsquo;ve found takes away some of the readability of the code, but appears to work reliably:</p>

<pre><code>render new JSON(rainbow)
</code></pre>

<h4 id="testing-content-negotiation">Testing Content Negotiation</h4>

<p>Grails allows automatic content negotiation using the <a href="http://grails.org/doc/2.3.4/ref/Controllers/withFormat.html">withFormat</a> block. However, setting the format in unit tests is something I keep tripping over. To set a specific response type use <code>response.format</code>:</p>

<pre><code class="language-groovy">@TestFor(MyController)
class MyControllerSpec {
	void &quot;test response&quot;() {
		response.format = 'xml'
		controller.action()
		expect:
		response.contentType == 'application/xml'
	}
}
</code></pre>

<p>Note that the value to use with <code>response.format</code> is <em>not</em> the mime type, it is the name of what is set in <code>grails-app/conf/Config.groovy</code> in the mime type settings. For example:</p>

<pre><code>grails.mime.types = [
		all: '*/*',
		json: ['application/json', 'text/json'],
		xml: ['text/xml', 'application/xml']
]
</code></pre>

<p>If you wanted an XML response, you&rsquo;d use <code>response.format = 'xml'</code> and <em>not</em> <code>response.format = 'application/xml'</code>.</p>

<hr />

<h2 id="integration-tests">Integration Tests</h2>

<h3 id="testing-services">Testing Services</h3>

<p>Services are really straightforward to test. You can even get Grails to automatically inject the service into your test:</p>

<pre><code class="language-groovy">class MyServiceSpecification extends Specification {

	MyService myService // Grails will inject the service

	void &quot;test my service method&quot;() {
		String result = myService.doMoreWork()

		expect:

		result == 'awesome'
	}
}
</code></pre>

<p>Grails will inject everything that is known to it into your integration test, including services or Grail&rsquo;s application context.</p>

<h3 id="integration-testing-services">Integration Testing Services</h3>

<p>Writing integration tests for services is very straightforward. You can get the instance injected directly into your test:</p>

<pre><code class="language-groovy">class MyControllerSpecification extends Specification {

	MyService myService // Injected by grails

	void &quot;test method on service ...&quot;() {
		service.myMethod()
		// ...
	}
}
</code></pre>

<h3 id="integration-testing-controllers">Integration Testing Controllers</h3>

<p>Integration testing controllers is just one step away from a full functional test, but has the advantage you don&rsquo;t need to deal with the HTTP details. Unlike a real functional test you don&rsquo;t require actual HTTP clients but you talk to the controller directly. Running the test in the same VM as the application under test also has the added benefit that you can look directly into the application to verify the correct behaviour, e.g. check if necessarey database tables have been created.</p>

<h4 id="dependencies">Dependencies</h4>

<p>Unlike services, controllers cannot be injected into integration tests so you&rsquo;ll have to create them. If your controller relies on a service, you&rsquo;ll have to manually inject it. You can get the service by getting it injected into your test:</p>

<pre><code class="language-groovy">class MyControllerSpecification extends Specification {

	MyService myService // We'll need this service for the controller

	MyController controller

	void setup() {
		// We have to create our own controller instance:
		controller = new MyController()
		// Manual dependency injection:
		controller.myService = myService
	}
}
</code></pre>

<h4 id="request-and-response">Request and Response</h4>

<p>During integration tests Grails will automatically set mocked <a href="http://grails.org/doc/latest/api/org/codehaus/groovy/grails/plugins/testing/GrailsMockHttpServletRequest.html">request</a> and <a href="http://grails.org/doc/latest/api/org/codehaus/groovy/grails/plugins/testing/GrailsMockHttpServletResponse.html">response</a> objects on your controllers. To set request parameters, assign values to <code>controller.params.myParam</code>.</p>

<p>If your controllers use content type negotiation, you&rsquo;ll have to set the expected content type on the <code>controller.response.format</code> field. Setting <code>controller.params.format</code> will <em>not</em> work and caused me all kinds of unexpected behaviour.</p>

<pre><code class="language-groovy">class MyControllerSpecification extends Specification {

	void setup() { }

	void &quot;test my controller action&quot;() {
		// Set request parameters:
		controller.params.productId = '42'

		// Set a content type:
		controller.response.format = 'json'

		// Call the controller action under test:
		controller.myAction()

		expect:

		controller.response.status == 200
		controller.response.contentAsString == '{&quot;productId&quot;:42,&quot;name&quot;:&quot;cake&quot;}'
	}
}
</code></pre>

<h2 id="other-references">Other References</h2>

<h3 id="grails-1-3">Grails 1.3</h3>

<p>Use this fantastic <a href="http://zanthrash.com/grailstesting/UnitTestingCheatSheet.pdf">testing cheatsheet for Grails 1.3.x.</a>.</p>

        </div>
    </div>
    <div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "ilikeorangutans" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    </main>
    
    <div class="divider"></div>
<div class="container grid-lg mb-2">
    <footer class="navbar text-gray">
        <section class="navbar-section">
            &copy; 2018 Jakob Külzer
        </section>
        <section class="navbar-center">
            <a href="mailto:jakob.kuelzer@gmail.com" class="btn btn-link">Email</a> |
            <a href="https://github.com/ilikeorangutans" target="_blank" class="btn btn-link">Github</a> |
            <a href="https://www.linkedin.com/in/jakobkuelzer/" target="_blank" class="btn btn-link">LinkedIn</a> |
            <a href="/index.xml" class="btn btn-link">RSS</a>
        </section>
        <section class="navbar-section"></section>
    </footer>
</div>

    
  </body>
</html>