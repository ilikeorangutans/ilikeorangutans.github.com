<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Software Development on Jakob Külzer</title><link>https://ilikeorangutans.github.io/tags/software-development/</link><description>Recent content in Software Development on Jakob Külzer</description><generator>Hugo</generator><language>en-ca</language><managingEditor>jakob.kuelzer@gmail.com (Jakob Külzer)</managingEditor><webMaster>jakob.kuelzer@gmail.com (Jakob Külzer)</webMaster><copyright>Jakob Külzer</copyright><lastBuildDate>Mon, 02 Jul 2018 12:06:44 -0400</lastBuildDate><atom:link href="https://ilikeorangutans.github.io/tags/software-development/index.xml" rel="self" type="application/rss+xml"/><item><title>Notes on Working Effectively With Legacy Code</title><link>https://ilikeorangutans.github.io/2018/07/02/notes-on-working-effectively-with-legacy-code/</link><pubDate>Mon, 02 Jul 2018 12:02:03 -0400</pubDate><author>jakob.kuelzer@gmail.com (Jakob Külzer)</author><guid>https://ilikeorangutans.github.io/2018/07/02/notes-on-working-effectively-with-legacy-code/</guid><description>&lt;p>I &lt;a href="https://ilikeorangutans.github.io/2018/06/18/book-arrival-working-effectivly-with-legacy-code/">recently received&lt;/a> my copy
of &lt;a href="https://www.goodreads.com/book/show/44919.Working_Effectively_with_Legacy_Code">Working Effectivly With Legacy Code&lt;/a>
and have been busy reading it. The book, as a product of its time, has examples of not only Java, but also C++, probably
to show concepts and techniques that apply to languages that behave differently in terms of linking and building. But
regardless of its examples not really applying to what I work with, it was full of useful vocabulary and techniques to
work with not only legacy systems, but really, any kind of system.&lt;/p></description></item><item><title>Book Arrival: Working Effectivly With Legacy Code</title><link>https://ilikeorangutans.github.io/2018/06/18/book-arrival-working-effectivly-with-legacy-code/</link><pubDate>Mon, 18 Jun 2018 22:58:46 -0400</pubDate><author>jakob.kuelzer@gmail.com (Jakob Külzer)</author><guid>https://ilikeorangutans.github.io/2018/06/18/book-arrival-working-effectivly-with-legacy-code/</guid><description>&lt;p>I had this book on my wishlist for quite a while, but never thought I needed it. But then it was warmly recommended to
me during a fantastic OOP Workshop with &lt;a href="https://www.sandimetz.com/">Sandi Metz&lt;/a>. If Sandi recommends it, it must be
good. Excited to dive into this one:&lt;/p>
&lt;!-- raw HTML omitted --></description></item><item><title>null, Software Design, and Scala's Option</title><link>https://ilikeorangutans.github.io/2018/05/26/null-software-design-and-scalas-option/</link><pubDate>Sat, 26 May 2018 12:13:10 -0400</pubDate><author>jakob.kuelzer@gmail.com (Jakob Külzer)</author><guid>https://ilikeorangutans.github.io/2018/05/26/null-software-design-and-scalas-option/</guid><description>&lt;p>For the past year or so I&amp;rsquo;ve been writing a lot of Scala and fallen in love with its &lt;code>Option&lt;/code> type and how it allows me to avoid &lt;code>null&lt;/code>s. I reflected on &lt;code>null&lt;/code>, why they are bad, and how optional types allow you to write more expressive code.&lt;/p>
&lt;h2 id="what-is-null">What is null?&lt;/h2>
&lt;p>Most programming languages have the concept of &lt;code>null&lt;/code> (or &lt;code>nil&lt;/code>) that represents the absence of a given value or object. At it&amp;rsquo;s surface the absence of a value probably just translates into a pointer of value &lt;code>0x0&lt;/code> or in languages that do not zero variables, a pointer anywhere into the memory. But aside from the implementation details the more interesting question is how &lt;code>null&lt;/code> fits into a language&amp;rsquo;s type system.&lt;/p></description></item><item><title>Inspiration and Action</title><link>https://ilikeorangutans.github.io/2018/03/30/inspiration-and-action/</link><pubDate>Fri, 30 Mar 2018 11:27:01 -0400</pubDate><author>jakob.kuelzer@gmail.com (Jakob Külzer)</author><guid>https://ilikeorangutans.github.io/2018/03/30/inspiration-and-action/</guid><description>&lt;p>I&amp;rsquo;m currently re-reading &lt;a href="https://www.amazon.com/gp/product/0321503627/ref=as_li_qf_asin_il_tl?ie=UTF8&amp;amp;tag=jakkuesblo-20&amp;amp;creative=9325&amp;amp;linkCode=as2&amp;amp;creativeASIN=0321503627&amp;amp;linkId=a9bf101a0a7973e0d0d78406aa41dc23">Growing Object-Oriented Software, Guided by Tests&lt;/a>, and this quote really spoke to me:&lt;/p>
&lt;blockquote>
&lt;p>We should be taught not to wait for inspiration to start a thing. Action always generates inspiration. Inspiration seldom generates action.&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>&amp;ndash; Frank Tibolt&lt;/p>&lt;/blockquote>
&lt;p>I think of myself as a perfectionist, the kind of person that hates to produce anything short of flawless. And while this is great quality to have because it drives me to improve and progress, it&amp;rsquo;s also incredibly crippling and frustrating. I&amp;rsquo;ve often noticed that while I had great ideas, I would often fail to implement them because I would try to over engineer my approach so it would solve everything perfectly. Obviously, many of these ideas and projects never went anywhere. But then on the contrary, ideas where I just started hacking something together often went much further and produced something usable and new.&lt;/p></description></item><item><title>Using Golang and Graphviz to Visualize Complex Grails Applications</title><link>https://ilikeorangutans.github.io/2014/05/03/using-golang-and-graphviz-to-visualize-complex-grails-applications/</link><pubDate>Sat, 03 May 2014 13:59:40 -0400</pubDate><author>jakob.kuelzer@gmail.com (Jakob Külzer)</author><guid>https://ilikeorangutans.github.io/2014/05/03/using-golang-and-graphviz-to-visualize-complex-grails-applications/</guid><description>&lt;p>At work we are maintaining several large and complex grails applications. In order to improve stability and reliability, we&amp;rsquo;re trying to increase test coverage. But as with all projects, time and resources are limited. In order to get a better understanding of what parts of the application are more important than others, I decided to use &lt;a href="http://www.graphviz.org/">Graphviz&lt;/a> to help me get a better overview of our applications.&lt;/p>
&lt;h3 id="meet-graphviz">Meet Graphviz&lt;/h3>
&lt;p>I discovered my love for the &lt;a href="http://www.graphviz.org/content/dot-language">dot language&lt;/a> when I used it years ago to analyze template hierarchies in a proprietary CMS system I worked on. In a nutshell, it lets you specify a graph with nodes and edges plus some extra attributes for labels, shapes etc. It&amp;rsquo;s really a concise little language:&lt;/p></description></item><item><title>The Case for Continuous Integration</title><link>https://ilikeorangutans.github.io/2013/06/01/the-case-for-continuous-integration/</link><pubDate>Sat, 01 Jun 2013 13:59:40 -0400</pubDate><author>jakob.kuelzer@gmail.com (Jakob Külzer)</author><guid>https://ilikeorangutans.github.io/2013/06/01/the-case-for-continuous-integration/</guid><description>&lt;p>In my career as a software developer, I&amp;rsquo;ve come to appreciate the principles of Continuous Integration (CI). It forces you to do the hard things early and often and thus helps you reduce risk during development. It forces you to write tests, and be responsible about what you check in. All in all, good qualities and something that every development team should aspire to. Or so I thought. Reality is different, and so far almost every development team I have interacted with is deadly afraid of doing CI. So much, that there&amp;rsquo;s been near-mutinies because CI and what it means for team, causes so many problems. This is something that puzzles me, and I realize it might be because the teams in question don&amp;rsquo;t fully understand what CI is or only realize a subset of what it means. This is my attempt to demystify and explain CI.&lt;/p></description></item><item><title>On Developer Happiness and Productivity</title><link>https://ilikeorangutans.github.io/2013/04/03/on-developer-happiness-and-productivity/</link><pubDate>Wed, 03 Apr 2013 13:59:40 -0400</pubDate><author>jakob.kuelzer@gmail.com (Jakob Külzer)</author><guid>https://ilikeorangutans.github.io/2013/04/03/on-developer-happiness-and-productivity/</guid><description>&lt;p>I&amp;rsquo;ve had the idea for this blog post in my mind for a long time. It is based on all my personal experiences and observations over the past years and is in no way scientific. It is my personal opinion, and even though this is how I perceive the world, it might not be true for other people. With that said, let&amp;rsquo;s jump to the core of things.&lt;/p>
&lt;blockquote>
&lt;p>A happy developer is a productive developer.&lt;/p></description></item></channel></rss>